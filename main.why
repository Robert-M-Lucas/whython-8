struct LL {
    has_first: bool,
    first: &Node
}

impl LL {
    fn new() -> LL {
        return LL {
            has_first: false,
            first: Node::null()
        };
    }

    fn add(&self, val: int) {
        if (*self.has_first) {
            (*self.first).add(val);
        } else {
            self.has_first = true;
            self.first = Node::new(val);
        };
    }

    fn print(&self) {
        if (*self.has_first) {
            (*self.first).print();
        };
    }
}

struct Node {
    val: int,
    has_next: bool,
    next: &Node
}

impl Node {
    fn new(val: int) -> &Node {
        return new Node {
            val: val,
            has_next: false,
            next: Node::null()
        };
    }

    fn add(&self, val: int) {
        if (*self.has_next) {
            (*self.next).add(val);
        } else {
            self.has_next = true;
            self.next = Node::new(val);
        };
    }

    fn print(&self) {
        printi(*self.val);
        if (*self.has_next) {
            (*self.next).print();
        };
    }
}

fn main() -> int {
    let r: LL = LL::new();
    r.add(2);
    r.add(3);
    r.add(2);
    r.add(1);
    r.print();

    return 0;
}